{
  "name": "Content Scheduler Monitor (E8)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{ "field": "minutes", "minutesInterval": 5 }]
        }
      },
      "id": "monitor-trigger",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:5678/api/v1/executions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "timeout": 10000
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "limit", "value": "100" },
            { "name": "status", "value": "error,crashed" }
          ]
        }
      },
      "id": "fetch-failed-executions",
      "name": "Fetch Failed Executions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [500, 200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "n8n-api-key",
          "name": "n8n API Key"
        }
      }
    },
    {
      "parameters": {
        "url": "http://localhost:5678/api/v1/executions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "timeout": 10000
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "limit", "value": "100" },
            { "name": "status", "value": "success" }
          ]
        }
      },
      "id": "fetch-success-executions",
      "name": "Fetch Success Executions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [500, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "n8n-api-key",
          "name": "n8n API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const failed = $('Fetch Failed Executions').first().json.data || [];\nconst success = $('Fetch Success Executions').first().json.data || [];\n\n// Calculate metrics\nconst now = new Date();\nconst oneHourAgo = new Date(now - 60 * 60 * 1000);\nconst oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);\n\nconst recentFailed = failed.filter(e => new Date(e.startedAt) > oneHourAgo);\nconst recentSuccess = success.filter(e => new Date(e.startedAt) > oneHourAgo);\n\nconst dailyFailed = failed.filter(e => new Date(e.startedAt) > oneDayAgo);\nconst dailySuccess = success.filter(e => new Date(e.startedAt) > oneDayAgo);\n\n// Calculate success rate\nconst hourlyTotal = recentFailed.length + recentSuccess.length;\nconst hourlySuccessRate = hourlyTotal > 0 ? (recentSuccess.length / hourlyTotal * 100).toFixed(2) : 100;\n\nconst dailyTotal = dailyFailed.length + dailySuccess.length;\nconst dailySuccessRate = dailyTotal > 0 ? (dailySuccess.length / dailyTotal * 100).toFixed(2) : 100;\n\n// Identify problematic workflows\nconst failedByWorkflow = {};\nfailed.forEach(e => {\n  const wfName = e.workflowName || 'Unknown';\n  failedByWorkflow[wfName] = (failedByWorkflow[wfName] || 0) + 1;\n});\n\nconst topFailingWorkflows = Object.entries(failedByWorkflow)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 5)\n  .map(([name, count]) => ({ workflow: name, failures: count }));\n\n// Determine health status\nlet healthStatus = 'healthy';\nlet alertLevel = 'info';\n\nif (parseFloat(hourlySuccessRate) < 80) {\n  healthStatus = 'degraded';\n  alertLevel = 'warning';\n}\nif (parseFloat(hourlySuccessRate) < 50 || recentFailed.length > 10) {\n  healthStatus = 'critical';\n  alertLevel = 'error';\n}\n\nconst metrics = {\n  timestamp: now.toISOString(),\n  health_status: healthStatus,\n  alert_level: alertLevel,\n  hourly: {\n    success: recentSuccess.length,\n    failed: recentFailed.length,\n    total: hourlyTotal,\n    success_rate: hourlySuccessRate + '%'\n  },\n  daily: {\n    success: dailySuccess.length,\n    failed: dailyFailed.length,\n    total: dailyTotal,\n    success_rate: dailySuccessRate + '%'\n  },\n  top_failing_workflows: topFailingWorkflows,\n  requires_alert: healthStatus !== 'healthy'\n};\n\nreturn [{ json: metrics }];"
      },
      "id": "calculate-metrics",
      "name": "Calculate Health Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [750, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.requires_alert }}",
              "value2": true
            }
          ]
        }
      },
      "id": "needs-alert",
      "name": "Needs Alert?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "metric-store",
              "name": "timestamp",
              "value": "={{ $json.timestamp }}",
              "type": "string"
            },
            {
              "id": "metric-health",
              "name": "health_status",
              "value": "={{ $json.health_status }}",
              "type": "string"
            },
            {
              "id": "metric-hourly-rate",
              "name": "hourly_success_rate",
              "value": "={{ $json.hourly.success_rate }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true
      },
      "id": "store-metrics",
      "name": "Log Metrics (No Alert)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_WEBHOOK_URL || 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL' }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ text: ':warning: *n8n Workflow Health Alert*', blocks: [{ type: 'section', text: { type: 'mrkdwn', text: '*Status:* ' + $json.health_status.toUpperCase() + '\\n*Hourly Success Rate:* ' + $json.hourly.success_rate + '\\n*Failed (1h):* ' + $json.hourly.failed + '\\n*Failed (24h):* ' + $json.daily.failed } }, { type: 'section', text: { type: 'mrkdwn', text: '*Top Failing Workflows:*\\n' + $json.top_failing_workflows.map(w => '- ' + w.workflow + ': ' + w.failures + ' failures').join('\\n') } }] }) }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "send-slack-alert",
      "name": "Send Slack Alert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "workflow_metrics",
        "columns": "timestamp,health_status,alert_level,hourly_success,hourly_failed,hourly_rate,daily_success,daily_failed,daily_rate",
        "options": {}
      },
      "id": "save-to-db",
      "name": "Save Metrics to DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1400, 300],
      "disabled": true,
      "notesInFlow": true,
      "notes": "Enable when PostgreSQL is configured"
    }
  ],
  "connections": {
    "Every 5 Minutes": {
      "main": [
        [
          { "node": "Fetch Failed Executions", "type": "main", "index": 0 },
          { "node": "Fetch Success Executions", "type": "main", "index": 0 }
        ]
      ]
    },
    "Fetch Failed Executions": {
      "main": [
        [{ "node": "Calculate Health Metrics", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Success Executions": {
      "main": [
        [{ "node": "Calculate Health Metrics", "type": "main", "index": 0 }]
      ]
    },
    "Calculate Health Metrics": {
      "main": [
        [{ "node": "Needs Alert?", "type": "main", "index": 0 }]
      ]
    },
    "Needs Alert?": {
      "main": [
        [{ "node": "Send Slack Alert", "type": "main", "index": 0 }],
        [{ "node": "Log Metrics (No Alert)", "type": "main", "index": 0 }]
      ]
    },
    "Send Slack Alert": {
      "main": [
        [{ "node": "Save Metrics to DB", "type": "main", "index": 0 }]
      ]
    },
    "Log Metrics (No Alert)": {
      "main": [
        [{ "node": "Save Metrics to DB", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    { "name": "monitoring" },
    { "name": "alerting" },
    { "name": "E8" }
  ],
  "triggerCount": 1,
  "meta": {
    "instanceId": "pubilie-doc",
    "templateId": "E8-content-scheduler-monitor"
  }
}
